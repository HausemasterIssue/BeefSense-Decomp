



package com.gamesense.client.module.modules.exploits;

import com.gamesense.client.module.*;
import com.gamesense.api.setting.*;
import net.minecraft.client.*;
import net.minecraft.init.*;
import net.minecraft.util.math.*;
import net.minecraft.network.*;
import com.gamesense.api.util.misc.*;
import net.minecraft.block.state.*;
import net.minecraft.util.*;
import net.minecraft.world.*;
import net.minecraft.entity.player.*;
import net.minecraft.entity.*;
import net.minecraft.network.play.client.*;
import net.minecraft.block.*;
import com.gamesense.api.util.player.*;
import java.util.*;

public class Burrow extends Module
{
    public static Setting.Mode mode;
    public static Setting.Mode glitchY;
    public static Setting.Integer tpHeight;
    public static Setting.Integer delay;
    public static Setting.Boolean rotate;
    public static Setting.Boolean center;
    public static Setting.Boolean offground;
    private final Timer timer;
    private int oldSlot;
    
    public Burrow() {
        super("Burrow", Module.Category.Exploits);
        this.timer = new Timer();
        this.oldSlot = -1;
    }
    
    public void onEnable() {
        super.onEnable();
        final Minecraft mc = Minecraft.getMinecraft();
        if (mc.player != null && InventoryUtil.getBlockCount(Blocks.OBSIDIAN) > 0) {
            if (InventoryUtil.findObsidianInHotbar(mc.player) != -1) {
                if (Burrow.center.getValue()) {
                    final double[] newPos = { Math.floor(mc.player.posX) + 0.5, mc.player.posY, Math.floor(mc.player.posZ) + 0.5 };
                    final CPacketPlayer.Position middleOfPos = new CPacketPlayer.Position(newPos[0], newPos[1], newPos[2], mc.player.onGround);
                    if (!mc.world.isAirBlock(new BlockPos(newPos[0], newPos[1], newPos[2]).down()) && mc.player.posX != middleOfPos.x && mc.player.posZ != middleOfPos.z) {
                        mc.player.connection.sendPacket((Packet)middleOfPos);
                        mc.player.setPosition(newPos[0], newPos[1], newPos[2]);
                    }
                }
                mc.player.jump();
                this.timer.reset();
            }
            else {
                MessageBus.sendClientPrefixMessage("You don't have any obsidian in your hotbar!");
                this.toggle();
            }
        }
    }
    
    private EnumFacing calcSide(final BlockPos pos) {
        for (final EnumFacing side : EnumFacing.values()) {
            final BlockPos sideOffset = pos.offset(side);
            final IBlockState offsetState = Minecraft.getMinecraft().world.getBlockState(sideOffset);
            if (offsetState.getBlock().canCollideCheck(offsetState, false)) {
                if (!offsetState.getMaterial().isReplaceable()) {
                    return side;
                }
            }
        }
        return null;
    }
    
    private boolean place(final BlockPos pos, final Minecraft mc) {
        final Block block = mc.world.getBlockState(pos).getBlock();
        final EnumFacing direction = this.calcSide(pos);
        if (direction == null) {
            return false;
        }
        final boolean activated = block.onBlockActivated((World)mc.world, pos, mc.world.getBlockState(pos), (EntityPlayer)mc.player, EnumHand.MAIN_HAND, direction, 0.0f, 0.0f, 0.0f);
        if (activated) {
            mc.player.connection.sendPacket((Packet)new CPacketEntityAction((Entity)mc.player, CPacketEntityAction.Action.START_SNEAKING));
        }
        final EnumFacing otherSide = direction.getOpposite();
        final BlockPos sideOffset = pos.offset(direction);
        mc.player.connection.sendPacket((Packet)new CPacketPlayerTryUseItemOnBlock(sideOffset, otherSide, EnumHand.MAIN_HAND, 0.5f, 0.5f, 0.5f));
        mc.player.connection.sendPacket((Packet)new CPacketAnimation(EnumHand.MAIN_HAND));
        if (activated) {
            mc.player.connection.sendPacket((Packet)new CPacketEntityAction((Entity)mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
        }
        return true;
    }
    
    public void onUpdate() {
        final Minecraft mc = Minecraft.getMinecraft();
        if (mc.player == null || mc.world == null) {
            return;
        }
        if (this.timer.passed((double)Burrow.delay.getValue()) && InventoryUtil.getBlockCount(Blocks.OBSIDIAN) > 0) {
            final HandSwapContext handSwapContext = new HandSwapContext(mc.player.inventory.currentItem, InventoryUtil.findObsidianInHotbar(mc.player));
            if (handSwapContext.getNewSlot() == -1) {
                return;
            }
            handSwapContext.handleHandSwap(false, mc);
            final BlockPos positionToPlaceAt = new BlockPos(mc.player.getPositionVector()).down();
            if (this.place(positionToPlaceAt, mc)) {
                if (Burrow.mode.getValue().equalsIgnoreCase("JUMP")) {
                    PlacementUtil.place(positionToPlaceAt, EnumHand.MAIN_HAND, true);
                    mc.player.jump();
                }
                if (Burrow.mode.getValue().equalsIgnoreCase("GLITCH")) {
                    mc.player.motionY = Float.parseFloat(Burrow.glitchY.getValue());
                }
                if (Burrow.mode.getValue().equalsIgnoreCase("TP")) {
                    mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(mc.player.posX, mc.player.posY - Burrow.tpHeight.getValue(), mc.player.posZ, mc.player.onGround));
                }
                this.toggle();
            }
        }
    }
    
    public void setup() {
        final ArrayList<String> floats = new ArrayList<String>();
        floats.add("0.5f");
        floats.add("0.1f");
        floats.add("1.5f");
        final ArrayList<String> modes = new ArrayList<String>();
        modes.add("JUMP");
        modes.add("GLITCH");
        modes.add("TP");
        Burrow.mode = this.registerMode("Mode", (List)modes, "JUMP");
        Burrow.glitchY = this.registerMode("Float", (List)floats, "0.5f");
        Burrow.tpHeight = this.registerInteger("ModeTPHeight", 1, 1, 10);
        Burrow.delay = this.registerInteger("Delay", 50, 1, 500);
        Burrow.rotate = this.registerBoolean("Rotate", false);
        Burrow.center = this.registerBoolean("Center", false);
        Burrow.offground = this.registerBoolean("offGround", false);
    }
}
