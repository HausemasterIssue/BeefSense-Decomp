



package com.gamesense.client.module.modules.exploits;

import com.gamesense.client.module.*;
import com.gamesense.api.setting.*;
import net.minecraft.item.*;
import net.minecraft.entity.item.*;
import net.minecraft.entity.*;
import net.minecraft.entity.player.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;
import java.util.*;
import net.minecraft.init.*;

public class PacketXP extends Module
{
    Setting.Integer minDamage;
    Setting.Integer maxHeal;
    Setting.Boolean noEntityCollision;
    Setting.Boolean sneakOnly;
    Setting.Boolean predict;
    char toMend;
    
    public PacketXP() {
        super("PacketXP", Module.Category.Exploits);
        this.toMend = '\0';
    }
    
    public void setup() {
        this.sneakOnly = this.registerBoolean("Sneak Only", true);
        this.noEntityCollision = this.registerBoolean("No Collision", true);
        this.minDamage = this.registerInteger("Min Damage", 50, 1, 100);
        this.maxHeal = this.registerInteger("Repair To", 90, 1, 100);
        this.predict = this.registerBoolean("Predict", false);
    }
    
    public void onUpdate() {
        if (PacketXP.mc.player == null || PacketXP.mc.world == null || PacketXP.mc.player.ticksExisted < 10) {
            return;
        }
        int sumOfDamage = 0;
        final List<ItemStack> armour = (List<ItemStack>)PacketXP.mc.player.inventory.armorInventory;
        for (int i = 0; i < armour.size(); ++i) {
            final ItemStack itemStack = armour.get(i);
            if (!itemStack.field_190928_g) {
                final float damageOnArmor = (float)(itemStack.getMaxDamage() - itemStack.getItemDamage());
                final float damagePercent = 100.0f - 100.0f * (1.0f - damageOnArmor / itemStack.getMaxDamage());
                if (damagePercent <= this.maxHeal.getValue()) {
                    if (damagePercent <= this.minDamage.getValue()) {
                        this.toMend |= (char)(1 << i);
                    }
                    if (this.predict.getValue()) {
                        sumOfDamage += (int)(itemStack.getMaxDamage() * this.maxHeal.getValue() / 100.0f - (itemStack.getMaxDamage() - itemStack.getItemDamage()));
                    }
                }
                else {
                    this.toMend &= (char)~(1 << i);
                }
            }
        }
        if (this.toMend > '\0') {
            if (this.predict.getValue()) {
                final int totalXp = PacketXP.mc.world.loadedEntityList.stream().filter(entity -> entity instanceof EntityXPOrb).filter(entity -> entity.getDistanceSqToEntity((Entity)PacketXP.mc.player) <= 1.0).mapToInt(entity -> entity.xpValue).sum();
                if (totalXp * 2 < sumOfDamage) {
                    this.mendArmor(PacketXP.mc.player.inventory.currentItem);
                }
            }
            else {
                this.mendArmor(PacketXP.mc.player.inventory.currentItem);
            }
        }
    }
    
    private void mendArmor(final int oldSlot) {
        if (this.noEntityCollision.getValue()) {
            for (final EntityPlayer entityPlayer : PacketXP.mc.world.playerEntities) {
                if (entityPlayer.getDistanceToEntity((Entity)PacketXP.mc.player) < 1.0f && entityPlayer != PacketXP.mc.player) {
                    return;
                }
            }
        }
        if (this.sneakOnly.getValue() && !PacketXP.mc.player.isSneaking()) {
            return;
        }
        final int newSlot = this.findXPSlot();
        if (newSlot == -1) {
            return;
        }
        if (oldSlot != newSlot) {
            PacketXP.mc.player.inventory.currentItem = newSlot;
        }
        PacketXP.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Rotation(0.0f, 90.0f, true));
        PacketXP.mc.rightClickMouse();
        PacketXP.mc.player.inventory.currentItem = oldSlot;
    }
    
    private int findXPSlot() {
        int slot = -1;
        for (int i = 0; i < 9; ++i) {
            if (PacketXP.mc.player.inventory.getStackInSlot(i).getItem() == Items.EXPERIENCE_BOTTLE) {
                slot = i;
                break;
            }
        }
        return slot;
    }
}
